generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Role {
  USER
  ADMIN
}

enum SkillLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
}

enum MembershipTier {
  GUEST
  PRO
  EXCLUSIVE
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
}

model User {
  id                     String          @id @default(cuid())
  name                   String?
  email                  String          @unique
  emailVerified          DateTime?
  image                  String?
  role                   Role            @default(USER)
  membershipTier         MembershipTier  @default(GUEST)
  membershipExpiresAt    DateTime?
  skillLevel             SkillLevel      @default(BEGINNER)
  availability           Json?
  createdAt              DateTime        @default(now())
  updatedAt              DateTime        @updatedAt
  loyaltyPointsBalance   Int             @default(0)
  
  accounts               Account[]
  sessions               Session[]
  bookings               Booking[]
  
  // Tournament Relations
  captainTeams           Team[]          @relation("TeamCaptain")

  // Friend Relations
  sentFriendRequests     Friend[]        @relation("sentFriendRequests")
  receivedFriendRequests Friend[]        @relation("receivedFriendRequests")

  // Messaging Relations
  conversations          Conversation[]  @relation("ConversationUsers")
  messages               Message[]

  // Match Relations
  matches                MatchPlayer[]

  // Loyalty Points Relations
  loyaltyPoints          LoyaltyPoint[]

  // Achievements Relations
  achievements           UserAchievement[]

  // Recurring Bookings Relations
  recurringBookings      RecurringBooking[]

  // Waitlist Relations
  waitlistEntries        WaitlistEntry[]
}

// ... (Account, Session, VerificationToken, Court models remain unchanged)
// We need to match the original file content for unchanged parts if we are replacing a block, 
// but here I will use the tool efficiently to just target specific areas if possible, 
// or replace the whole file if it's cleaner. Given the tool `replace_file_content` works on exact match,
// it is safer to replace large chunks or specific blocks. 

// I will replace the User model and add the new Enum.
// Then I will handle Booking and PromoCode. 

// Actually, I'll do it in one go for the whole schema if the file is small, 
// but "replace_file_content" is better with specific targets.

// Let's replace from `enum Role` down to `model Account` start to inject MembershipTier and User updates.

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  BLOCKED
}

model Friend {
  id           String           @id @default(cuid())
  requesterId  String
  receiverId   String
  status       FriendshipStatus @default(PENDING)
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  requester    User             @relation("sentFriendRequests", fields: [requesterId], references: [id], onDelete: Cascade)
  receiver     User             @relation("receivedFriendRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([requesterId, receiverId])
}

model Conversation {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  users     User[]    @relation("ConversationUsers")
  messages  Message[]
}

model Message {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  body           String       @db.Text
  conversationId String
  senderId       String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
}


// NextAuth models
model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?  @db.Text
  access_token       String?  @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?  @db.Text
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum CourtType {
  INDOOR
  OUTDOOR
}

enum CourtSurface {
  GRASS
  CARPET
}

model Court {
  id                 String             @id @default(cuid())
  name               String
  description        String?
  pricePerHour       Int                // Rupiah
  type               CourtType          @default(INDOOR)
  surface            CourtSurface       @default(CARPET)
  isActive           Boolean            @default(true)
  imageUrl           String?            // For the card display
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  bookings           Booking[]
  recurringBookings  RecurringBooking[]
  waitlistEntries    WaitlistEntry[]
}

model Booking {
  id                String        @id @default(cuid())
  userId            String?       // Made optional for guest bookings
  courtId           String
  startTime         DateTime
  endTime           DateTime
  totalPrice        Int           // Rupiah (Final price after discount)
  originalPrice     Int           @default(0)
  discountApplied   Int           @default(0)
  status            BookingStatus @default(PENDING)
  lookingForPlayers Boolean       @default(false)
  
  // Customer details (for guest bookings or override)
  customerName      String?
  customerEmail     String?
  customerPhone     String?
  
  // Promo Code
  promoCodeId       String?

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  user      User?      @relation(fields: [userId], references: [id])
  court     Court      @relation(fields: [courtId], references: [id])
  promoCode PromoCode? @relation(fields: [promoCodeId], references: [id])
  payment   Payment?

  // Indexes for performance (schedule matrix queries)
  @@index([courtId, startTime, endTime])
  @@index([userId])
  @@index([status])
}

model RecurringBooking {
  id        String   @id @default(cuid())
  userId    String
  courtId   String
  startTime DateTime
  endTime   DateTime
  rule      String   // "weekly" or "bi-weekly"
  endDate   DateTime
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  court     Court    @relation(fields: [courtId], references: [id], onDelete: Cascade)
}

model WaitlistEntry {
  id        String   @id @default(cuid())
  userId    String
  courtId   String
  startTime DateTime
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  court     Court    @relation(fields: [courtId], references: [id], onDelete: Cascade)

  @@unique([userId, courtId, startTime])
}

model PromoCode {
  id        String   @id @default(cuid())
  code      String   @unique
  discount  Int      // Value of discount
  type      String   // "PERCENTAGE" or "FIXED"
  value     Int      // Redundant? No, discount can be the displayed text/value. Let's simplify: 
                   // If type is PERCENTAGE, value is 0-100. If FIXED, value is Rupiah.
  isActive  Boolean  @default(true)
  expiresAt DateTime?
  maxUses   Int?
  usedCount Int      @default(0)
  
  bookings  Booking[]
}

model Payment {
  id         String    @id @default(cuid())
  bookingId  String    @unique
  amount     Int       // Rupiah
  provider   String    // "midtrans" / "simulation"
  externalId String?   // Midtrans Order ID
  snapToken  String?   // Midtrans Snap Token
  status     String    // PENDING, SUCCESS, FAILED
  paidAt     DateTime? // When payment was completed
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  booking Booking @relation(fields: [bookingId], references: [id])
}

// --- TOURNAMENT SYSTEM ---

enum TournamentStatus {
  REGISTRATION
  ACTIVE
  FINISHED
}

enum TournamentFormat {
  KNOCKOUT
  ROUND_ROBIN
}

model Tournament {
  id          String           @id @default(cuid())
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  status      TournamentStatus @default(REGISTRATION)
  format      TournamentFormat @default(KNOCKOUT)
  price       Int              @default(0)
  prizePool   String?
  maxTeams    Int              @default(8)

  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  teams       Team[]
  matches     TMatch[]
}

model Team {
  id           String     @id @default(cuid())
  name         String
  captainId    String
  tournamentId String
  
  status       String     @default("PENDING") // PENDING, APPROVED, REJECTED

  captain      User       @relation("TeamCaptain", fields: [captainId], references: [id])
  tournament   Tournament @relation(fields: [tournamentId], references: [id])
  
  homeMatches  TMatch[]   @relation("HomeTeam")
  awayMatches  TMatch[]   @relation("AwayTeam")
  wonMatches   TMatch[]   @relation("MatchWinner")

  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
}

model TMatch {
  id            String     @id @default(cuid())
  tournamentId  String
  
  round         Int        // 1=Finals, 2=Semis, etc. (Distance from root)
  position      Int        // Horizontal position in bracket

  teamAId       String?
  teamBId       String?
  winnerId      String?

  score         String?    // "6-4, 6-2"

  startTime     DateTime? // Scheduled time
  courtId       String?   // Linked real court booking?

  // Bracket Linkage
  nextMatchId   String?
  nextMatch     TMatch?   @relation("BracketPath", fields: [nextMatchId], references: [id])
  prevMatches   TMatch[]  @relation("BracketPath")

  tournament    Tournament @relation(fields: [tournamentId], references: [id])
  teamA         Team?      @relation("HomeTeam", fields: [teamAId], references: [id])
  teamB         Team?      @relation("AwayTeam", fields: [teamBId], references: [id])
  winner        Team?      @relation("MatchWinner", fields: [winnerId], references: [id])
}

model Match {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  teamAScore  Int
  teamBScore  Int
  winnerTeam  String // "A" or "B"

  players     MatchPlayer[]
}

model MatchPlayer {
  matchId   String
  userId    String
  team      String // "A" or "B"

  match     Match  @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([matchId, userId])
}

model LoyaltyPoint {
  id        String   @id @default(cuid())
  userId    String
  points    Int
  reason    String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Reward {
  id          String  @id @default(cuid())
  name        String
  description String
  pointsCost  Int
  isActive    Boolean @default(true)
}

model Achievement {
  id               String            @id @default(cuid())
  name             String
  description      String
  icon             String
  criteria         Json
  userAchievements UserAchievement[]
}

model UserAchievement {
  userId        String
  achievementId String
  createdAt     DateTime @default(now())

  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@id([userId, achievementId])
}
